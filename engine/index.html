<html>
    <head>
        <link rel="stylesheet" href="main.css"/>
        <link rel="stylesheet" href="chessboard.css"/>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
        <script src="chess.js"></script>
        <script src="chessboard.js"></script>
        <script src="chessboard_detection.js"></script>
        <script src="filters.js"></script>
    </head>
    <body>
        <div id="campreview-edge-container">
            <video id="campreviewfeed" width="200" height="150" autoplay></video>
            <canvas id="edgedetect" width="200" height="150"></canvas>
        </div>
        <canvas id="camcrop" width="256" height="256"></canvas>
        <div id="rawdetect"></div>
        <div id="board"></div>
        <script>
            let stockfish = new Worker("stockfish.js");
            let chess = Chess();
            let board = Chessboard('board', {
                position: 'start',
                pieceTheme: 'chesspieces/{piece}.png'
            });

            let skill = 0;
            let max_err = 10;
            let err_prob = 1;
            let depth = 1;
            let moves = [];
            let promotion_pref = 'q';

            /* INIT */
            window.onload = async function () {
                setDifficulty(5);
                resetGame();

                console.log(navigator, navigator.mediaDevices, navigator.getUserMedia);
                let stream; 

                try {
                    console.log("attempting to use back camera...");
                    stream = await navigator.mediaDevices.getUserMedia({ video: {
                        facingMode: { exact: "environment" }
                    }});
                } catch(err) {
                    console.log("falling back camera...");
                    stream = await navigator.mediaDevices.getUserMedia({ video: true });
                }

                var canvas = document.createElement("canvas");
                let video = document.getElementById("campreviewfeed");
                video.srcObject = stream;
                video.addEventListener( "loadedmetadata", function (e) {
                    const
                    width = this.videoWidth,
                        height = this.videoHeight;
                    canvas.width = width;
                    canvas.height = height;

                    console.log("video dimensions", width, height);

                    function scheduleNextDetection() {
                        setTimeout((timeout) => {
                            canvas.getContext('2d').drawImage(video, 0, 0, width, height);
                            let image = new Image();
                            image.src = canvas.toDataURL('image/jpeg');

                            image.addEventListener('load', function() {
                                processLoadedImage(image);
                                scheduleNextDetection();
                            });
                        }, 1500);
                    }
                    scheduleNextDetection();
                }, false);
            }

            /* STOCKFISH CONFIG */
            stockfish.onmessage = function(event) {
                let response = (event.data ? event.data : event);
                console.log("-> RESPONSE: ", response);
                processReply(response);
            }

            function sendCmds(instructions) {
                for (let instruction of instructions) {
                    console.log("<- REQUEST : ", instruction);
                    stockfish.postMessage(instruction);
                }
            }
            function processReply(response) {
                if (typeof response === 'string' || response instanceof String) {
                    let msg = response.split(" ");
                    if (msg[0] == "bestmove") {
                        robotMove(splitInstSquares(msg[1]))
                    }
                }
            }

            /* USER CONFIG */
            function setPromotionPref(piece) {
                promotion_pref = piece;
            }

            /* CHESSJS CONFIG */
            function moveHasCapture(m) {
                var arr = [];
                m = splitInstSquares(m);

                for (row of chess.board()) for (e of row) arr.push(e);
                let start = arr; arr = [];
                let end = start;
                if (chess.move({from: m[0], to: m[1]})) {
                    for (row of chess.board()) for (e of row) arr.push(e);
                    end = arr; arr = [];
                    chess.undo();
                }

                console.log(start,end);
                start = start.map((x)=>{return x == null ? 0 : 1}).reduce((a, b) => {return a + b}, 0);
                end   = end.map((x)=>{return x == null ? 0 : 1}).reduce((a, b) => {return a + b}, 0);

                console.log(start,end);
                if (end >= start) return null;

                if (chess.get(m[0]).type == 'p' && chess.get(m[1]) === null) {
                    //en passant
                    return m[1][0] + m[0][1];
                } else {
                    return m[1];
                }
            }

            function moveHasCastleMove(m) {
                m = splitInstSquares(m);
                if (chess.get(m[0]).type != 'k') return null;

                let row = m[0][1];
                if (row != m[1][1] || (row != '1' && row != '8')) return null;

                let from = m[0][0];
                let to   = m[1][0];

                if (from != "e") return null;
                if (to == "g") return "h" + row + "f" + row;
                if (to == "c") return "a" + row + "d" + row;
                return splitInstSquares(m);
            }
            function moveHasPromotion(m) {
                m = splitInstSquares(m);
                if (chess.get(m[0]).type != 'p') return null;

                let from = m[0][1] - 0;
                let to   = m[1][1] - 0;

                if ((to == 8 || to == -1) && Math.abs(from-to) == 1) {
                    if (m.length > 2) {
                        return m[2];
                    }
                    return promotion_pref;
                }
                return null;
            }

            /* GENERAL HELPERS */
            function splitInstSquares(move) {
                if (typeof move === 'string' || move instanceof String) {
                    let ans = [move[0] + move[1], move[2] + move[3]];
                    if (move.length > 4) ans.push(move[4]);
                    return ans;
                }
                return move
            }
            function setDifficulty(d) {
                skill = d;
                err_prob = Math.round((skill * 6.35) + 1);
                max_err = Math.round((skill * -0.5) + 10);

                if (skill < 5) {
                    depth = "1";
                } else if (skill < 10) {
                    depth = "3";
                } else if (skill < 15) {
                    depth = "5";
                } else {
                    /// Let the engine decide.
                    depth = "";
                }

                sendCmds([
                    "setoption name Skill Level value " + skill,
                    "setoption name Skill Level Maximum Error value " + max_err,
                    "setoption name Skill Level Probability value " + err_prob,
                ]);
            }
            function resetGame() {
                sendCmds([
                    "ucinewgame",
                    "isready"
                ]);
                board.start();
                chess = Chess();
                console.log(chess.ascii());
                moves = [];
            }

        </script>
        <script>
            function playerMove(m, ignore) {
                m = splitInstSquares(m);
                let promotion = moveHasPromotion(m);
                if (!chess.move({from: m[0], to: m[1], promotion: promotion})) return false;

                console.log("Player moved " + m);
                moves.push(m.join(""));
                board.position(chess.fen())
 
                console.log(chess.ascii());

                if (ignore) return true;
                if (chess.game_over()) {
                    handleGameOver();
                    return true;
                }
                sendCmds([
                    "position startpos moves " + moves.join(" "),
                    "eval",
                    "go depth " + depth + "wtime 300000 winc 2000 btime 300000 binc 2000"
                ]);
                return true;
            }
            function robotMove(m) {
                m = splitInstSquares(m);
                let captures = moveHasCapture(m);
                let castles = moveHasCastleMove(m);
                let promotion = moveHasPromotion(m);
                if (chess.move({from: m[0], to: m[1], promotion: promotion})) {

                    console.log(
                        "Robot to move " + m
                        + ", capture=" + captures + ", castle=" + castles
                        + ", promotion=" + promotion
                    );

                    if (captures)
                        sendRobotMoves([captures + m[0][0] + '9', m[0] + m[1]]);
                    else if (castles)
                        sendRobotMoves([m[0] + m[1], castles[0] + castles[1]]);
                    else
                        sendRobotMoves([m[0] + m[1]]);

                    moves.push(m.join(""));
                    board.position(chess.fen())

                    console.log("Robot moved " + m);
                    console.log(chess.ascii());

                    if (chess.game_over()) {
                        handleGameOver();
                        return true;
                    }
                }
            }
            function handleGameOver() {
                console.log("Game Over");
            }
            function sendRobotMoves(moves) {
                for (let move of moves) {
                    let m = splitInstSquares(move);
                    console.log("Preparing robot move message: " + m);
                }
            }
        </script>
    </body>
</html>
