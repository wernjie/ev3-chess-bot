<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="main.css"/>
        <link rel="stylesheet" href="chessboard.css"/>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
        <script src="chess.js"></script>
        <script src="chessboard.js"></script>
        <script src="chessboard_detection.js"></script>
        <script src="chesspiece_detection.js"></script>
        <script src="filters.js"></script>
    </head>
    <body>
        <div id="statustext"></div>
        <div id="top-preview-container">
            <div id="campreview-edge-container">
                <video id="campreviewfeed" width="200" height="150" autoplay></video>
                <canvas id="edgedetect" width="200" height="150"></canvas>
            </div>
            <canvas id="camcrop" width="256" height="256"></canvas>
            <div id="calcdetect"></div>
            <div id="finaldetect"></div>
        </div>
        <div id="board"></div>
        <div id="robotsignal"></div>
        <div id="button-container">
            <button id="reset" onclick="resetGame()">New Game</button>
            <button id="torch" onclick="toggleTorch()">Toggle Flashlight</button>
            <button id="fullscreen" onclick="toggleFullscreen()">Fullscreen</button>
        </div>
        <div id="landscape-mode-hint"><b>ev3-chess-bot engine</b><br><br>Please use landscape mode.</div>
        <script>
            let robotSignalElement = document.getElementById('robotsignal');
            let statusTextElement = document.getElementById('statustext');

            let video = document.getElementById("campreviewfeed");
            let stream;

            let resultCanvasElement = document.getElementById("camcrop");
            let sobelCanvas = document.getElementById('edgedetect');

            let stockfish = new Worker("stockfish.js");
            let chess = Chess();
            let board = Chessboard('board', {
                position: 'start',
                pieceTheme: 'chesspieces/{piece}.png',
                showNotation: false
            });

            let skill = 0;
            let max_err = 10;
            let err_prob = 1;
            let depth = 1;
            let moves = [];
            let promotion_pref = 'q';

            /* INIT */
            window.onload = async function () {
                setDifficulty(5);
                resetGame();

                resetRobotSignal();
                setStatusText('Camera access required...');

                console.log(navigator, navigator.mediaDevices, navigator.getUserMedia);

                try {
                    console.log("attempting to use back camera...");
                    stream = await navigator.mediaDevices.getUserMedia({ video: {
                        aspectRatio: 1,
                        facingMode: { exact: "environment" }
                    }});
                } catch(err) {
                    console.log("falling back camera...");
                    stream = await navigator.mediaDevices.getUserMedia({ video: true });
                }

                var canvas = document.createElement("canvas");
                video.autoplay = true;
                video.muted = true;
                video.playsInline = true;
                video.srcObject = stream;
                video.play();
                video.addEventListener( "loadedmetadata", function (e) {
                    const
                    width = this.videoWidth,
                        height = this.videoHeight;
                    canvas.width = width;
                    canvas.height = height;

                    console.log("video dimensions", width, height);

                    function scheduleNextDetection() {
                        setTimeout((timeout) => {
                            canvas.getContext('2d').drawImage(video, 0, 0, width, height);
                            let image = new Image();
                            image.src = canvas.toDataURL('image/jpeg');

                            image.addEventListener('load', function() {
                                if (!signallingRobotMove) {
                                    processLoadedImage(image, resultCanvasElement, sobelCanvas);
                                    let result = locateChessPiecesInCanvas(resultCanvasElement);
                                    processChessPiecesResult(result);
                                }
                                scheduleNextDetection();
                            });
                        }, 500);
                    }
                    setTimeout(scheduleNextDetection, 1000);
                }, false);
            }

            /* STOCKFISH CONFIG */
            stockfish.onmessage = function(event) {
                let response = (event.data ? event.data : event);
                console.log("-> RESPONSE: ", response);
                processReply(response);
            }

            function sendCmds(instructions) {
                for (let instruction of instructions) {
                    console.log("<- REQUEST : ", instruction);
                    stockfish.postMessage(instruction);
                }
            }
            function processReply(response) {
                if (typeof response === 'string' || response instanceof String) {
                    let msg = response.split(" ");
                    if (msg[0] == "bestmove") {
                        (async () => {
                            await waitMS(400);
                            robotMove(splitInstSquares(msg[1]))
                        })();
                    }
                }
            }

            /* USER CONFIG */
            function setPromotionPref(piece) {
                promotion_pref = piece;
            }

            /* CHESSJS CONFIG */
            function moveHasCapture(m) {
                var arr = [];
                m = splitInstSquares(m);

                for (row of chess.board()) for (e of row) arr.push(e);
                let start = arr; arr = [];
                let end = start;
                if (chess.move({from: m[0], to: m[1]})) {
                    for (row of chess.board()) for (e of row) arr.push(e);
                    end = arr; arr = [];
                    chess.undo();
                }

                console.log(start,end);
                start = start.map((x)=>{return x == null ? 0 : 1}).reduce((a, b) => {return a + b}, 0);
                end   = end.map((x)=>{return x == null ? 0 : 1}).reduce((a, b) => {return a + b}, 0);

                console.log(start,end);
                if (end >= start) return null;

                if (chess.get(m[0]).type == 'p' && chess.get(m[1]) === null) {
                    //en passant
                    return m[1][0] + m[0][1];
                } else {
                    return m[1];
                }
            }

            function moveHasCastleMove(m) {
                m = splitInstSquares(m);
                if (chess.get(m[0]).type != 'k') return null;

                let row = m[0][1];
                if (row != m[1][1] || (row != '1' && row != '8')) return null;

                let from = m[0][0];
                let to   = m[1][0];

                if (from != "e") return null;
                if (to == "g") return "h" + row + "f" + row;
                if (to == "c") return "a" + row + "d" + row;
                return splitInstSquares(m);
            }
            function moveHasPromotion(m) {
                m = splitInstSquares(m);
                if (chess.get(m[0]).type != 'p') return null;

                let from = m[0][1] - 0;
                let to   = m[1][1] - 0;

                if ((to == 8 || to == -1) && Math.abs(from-to) == 1) {
                    if (m.length > 2) {
                        return m[2];
                    }
                    return promotion_pref;
                }
                return null;
            }

            /* GENERAL HELPERS */
            function splitInstSquares(move) {
                if (typeof move === 'string' || move instanceof String) {
                    let ans = [move[0] + move[1], move[2] + move[3]];
                    if (move.length > 4) ans.push(move[4]);
                    return ans;
                }
                return move
            }
            function setDifficulty(d) {
                skill = d;
                err_prob = Math.round((skill * 6.35) + 1);
                max_err = Math.round((skill * -0.5) + 10);

                if (skill < 5) {
                    depth = "1";
                } else if (skill < 10) {
                    depth = "3";
                } else if (skill < 15) {
                    depth = "5";
                } else {
                    /// Let the engine decide.
                    depth = "";
                }

                sendCmds([
                    "setoption name Skill Level value " + skill,
                    "setoption name Skill Level Maximum Error value " + max_err,
                    "setoption name Skill Level Probability value " + err_prob,
                ]);
            }
            function resetGame() {
                sendCmds([
                    "ucinewgame",
                    "isready"
                ]);
                board.start();
                chess = Chess();
                console.log(chess.ascii());
                moves = [];
                awaitingStartPos = true;
                awaitingRobotMove = false;
                possibleUserMove = "";
                possibleMoveConfidence = 0;
            }

            function toggleFullscreen() {
                if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
                    let exitFS = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
                    exitFS.call(document);
                } else {
                    let fs = document.documentElement.requestFullscreen || document.documentElement.mozRequestFullScreen || document.documentElement.webkitRequestFullscreen || document.documentElement.msRequestFullscreen;
                    if (fs) fs.call(document.documentElement);
                    else {
                        //detect iphone user
                        if (navigator.userAgent.match(/iPhone/i)) {
                            alert("Please use Safari, tap the 'Aa' button, then tap 'Hide Toolbar' for fullscreen use.");
                        } else {
                            alert("Your browser does not support fullscreen mode.");
                        }
                    }
                }
            }

            let torchState = false;
            function toggleTorch() {
                if (stream) {
                    torchState = !torchState;
                    stream.getVideoTracks().forEach(function(track) {
                        track.applyConstraints({
                            advanced: [{torch: torchState}]
                        });
                    });
                    alert("Flashlight is now " + (torchState ? "ON" : "OFF") + " if available.\n\niPhone and iPad currently might not be supported.");
                } else {
                    alert("Camera not running. Refresh page and try again, remembering to allow camera access.");
                }
            }


            //
            // Movement processing
            //

            let awaitingStartPos = true;
            let signallingRobotMove = false;
            let awaitingRobotMove = false;
            let possibleUserMove = "";
            let possibleMoveConfidence = 0;
            let cachedDetectedBoardState = {};
            let cachedDetectedBoardStateConfidence = 0;

            let tts;
            let synth = window.speechSynthesis;

            async function waitMS(ms) {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        resolve();
                    }, ms);
                });
            }
            function objectKeyPairEqual(obj1, obj2) {
                let keys1 = Object.keys(obj1);
                let keys2 = Object.keys(obj2);
                if (keys1.length != keys2.length) return false;
                for (let key of keys1) {
                    if (obj1[key] != obj2[key]) return false;
                }
                return true;
            }
            async function sendRobotMoves(moves) {
                awaitingRobotMove = true;
                for (let move of moves) {
                    let m = splitInstSquares(move);
                    await signalMove(m);
                }
                resetRobotSignal();
            }
            async function signalMove(m) {
                console.log("Signalling robot move message: " + m);
                signallingRobotMove = true;
                m = splitInstSquares(m);
                let from = m[0];
                let to   = m[1];

                if (to.indexOf("9") != -1) {
                    setStatusText("AI discard " + from, true);
                } else {
                    setStatusText("AI move " + from + to, true);
                }

                let val1 = "abcdefgh".indexOf(from[0]) + 1;
                let val2 = 9 - from[1];
                let val3 = "abcdefgh".indexOf(to[0]) + 1;
                let val4 = 9 - to[1];

                if (val1 > 8 || val2 > 8 || val3 > 8 || val4 > 8) {
                    console.log("attempted signal invalid move");
                    return;
                }
                if (val1 < 1 || val2 < 1 || val3 < 0 || val4 < 0) {
                    console.log("attempted signal invalid move");
                    return;
                }

                console.log(val1, val2, val3, val4);

                //transmit move to robot by flashing signal element
                let sepColor = "#ffffff";
                let dataColor = "#aaaaaa";
                let minTime = 100;
                let vals = [val1, val2, val3, val4];
                let el = robotSignalElement;

                let coloursToFlash = [];
                let transmitColor = function(w) {
                    coloursToFlash.push(w ? dataColor: sepColor);
                    if (!w) coloursToFlash.push(sepColor);
                    coloursToFlash.push("black");
                }

                transmitColor(0);
                for (let val of vals) {
                    for (let i = 0; i < val; i++) {
                        transmitColor(1);
                    }
                    transmitColor(0);
                }
                return new Promise((resolve, reject) => {
                    let timer = setInterval(() => {
                        if (coloursToFlash.length == 0) {
                            clearInterval(timer);
                            signallingRobotMove = false;
                            console.log("Signal complete");
                            resolve();
                            return;
                        }
                        let color = coloursToFlash.shift();
                        el.style.backgroundColor = color;
                    }, minTime);
                });
            }
            function resetRobotSignal() {
                robotSignalElement.style.backgroundColor = "black";
            }

            function setStatusText(text, speak, interrupt) {
                statusTextElement.innerText = text;
                if (speak || interrupt) {
                    speakText(speak ? text : undefined, interrupt);
                }
            }
            function speakText(text, interrupt) {
                if (tts && tts.text != text && synth && interrupt) {
                    console.log("Cancelling speech", tts.text, text);
                    synth.cancel();
                    tts = undefined;
                }
                if (synth && text) {
                    if (tts && tts.text == text) {
                        return;
                    }
                    tts = new SpeechSynthesisUtterance(text);
                    tts.lang = "en-US";
                    tts.onerror = function (event) {
                        console.error('SpeechSynthesisUtterance.onerror', event);
                    }
                    synth.speak(tts);
                    console.log("Speaking:", text);
                }
            }

            function processChessPiecesResult(result) {
                if (signallingRobotMove) {
                    return;
                }

                if (chess.game_over()) {
                    if (chess.in_checkmate()) {
                        setStatusText("Checkmate!", true);
                    } else if (chess.in_stalemate()) {
                        setStatusText("Stalemate!", true);
                    } else if (chess.in_draw()) {
                        setStatusText("Draw!", true);
                    } else if (chess.in_threefold_repetition()) {
                        setStatusText("Threefold repetition!", true);
                    } else if (chess.in_insufficient_material()) {
                        setStatusText("Insufficient material!", true);
                    } else if (chess.in_repetition()) {
                        setStatusText("Repetition!", true);
                    } else if (chess.in_draw()) {
                        setStatusText("Draw!", true);
                    } else {
                        setStatusText("Game over!", true);
                    }
                    return;
                }

                let detectedBoard = result.board;
                if (objectKeyPairEqual(detectedBoard, cachedDetectedBoardState)) {
                    cachedDetectedBoardStateConfidence++;
                } else {
                    cachedDetectedBoardStateConfidence = 0;
                    cachedDetectedBoardState = detectedBoard;
                }

                let boardStable = cachedDetectedBoardStateConfidence >= 3;
                let boardValidFraction = result.validFraction;
                let boardValid = boardValidFraction > 0.95;

                if (!boardValid) {
                    if (awaitingRobotMove) {
                        setStatusText("AI moving, do not interfere...", true);
                    } else {
                        setStatusText("Chessboard not in view", false, true);
                    }
                    return;
                }

                if (awaitingRobotMove || awaitingStartPos) {
                    if (awaitingRobotMove) {
                        setStatusText("AI moving, do not interfere...", true);
                    } else {
                        setStatusText("Waiting for start position...", true, true);
                    }

                    for (let x of "12345678") {
                        for (let y of "abcdefgh") {
                            let square = y + x;
                            let detectedPieceColor = detectedBoard[square];
                            let currentPieceColor = chess.get(square) ? chess.get(square).color.toUpperCase() : undefined;
                            if (detectedPieceColor != currentPieceColor) {
                                return;
                            }
                        }
                    }

                    if (awaitingRobotMove) {
                        setStatusText("AI move complete", true, true);
                    }

                    awaitingRobotMove = false;
                    awaitingStartPos = false;
                    return;
                }

                if (!boardStable) {
                    setStatusText("Chessboard interference detected");
                    return;
                }


                let blackLost = [];
                let whiteLost = [];
                let blackGain = [];
                let whiteGain = [];

                for (let x of "12345678") {
                    for (let y of "abcdefgh") {
                        let square = y + x;
                        let detectedPieceColor = detectedBoard[square] ? detectedBoard[square].toLowerCase() : undefined;
                        let currentPieceColor = chess.get(square) ? chess.get(square).color.toLowerCase() : undefined;
                        if (detectedPieceColor != currentPieceColor) {
                            if (currentPieceColor == "b") {
                                blackLost.push(square);
                            } else if (currentPieceColor == "w") {
                                whiteLost.push(square);
                            }

                            if (detectedPieceColor == "b") {
                                blackGain.push(square);
                            } else if (detectedPieceColor == "w") {
                                whiteGain.push(square);
                            }
                        }
                    }
                }

                //Assume white to move only
                if (whiteLost.length != whiteGain.length) {
                    console.log("white inconsistency detected: " + whiteLost + " to " + whiteGain);
                    if (whiteLost.length > whiteGain.length) {
                        setStatusText("Invalid move - unexpected white piece removal: " + whiteLost);
                    } else {
                        setStatusText("Invalid move - unexpected extra white piece: " + whiteGain);
                    }
                    speakText("Invalid move");
                    possibleMoveConfidence = 0;
                    possibleUserMove = "";
                    return;
                }
                if (blackGain.length > 0 || blackLost.length >= 2) {
                    console.log("non-white legal move detected: " + whiteLost + " to " + whiteGain + "; " + blackLost + " to " + blackGain);
                    if (blackLost.length == 0) {
                        setStatusText("Invalid move - unexpected black piece(s) gain: " + blackGain);
                    } else if (blackGain.length == 0) {
                        setStatusText("Invalid move - unexpected black pieces removed: " + blackLost);
                    } else {
                        setStatusText("Invalid move - unexpected black pieces moved: " + blackLost + " to " + blackGain);
                    }
                    speakText("Invalid move");

                    possibleMoveConfidence = 0;
                    possibleUserMove = "";
                    return;
                }

                let move = "";
                if (whiteGain.length == 0) {
                    setStatusText("Waiting for player move...", true, true);
                    return;
                } else if (whiteGain.length == 1) {
                    move = whiteLost[0] + whiteGain[0];
                } else if (whiteGain.length == 2) {
                    let kingMoved = whiteLost.indexOf("e1") != -1;
                    let hRookMoved = whiteLost.indexOf("h1") != -1;
                    let aRookMoved = whiteLost.indexOf("a1") != -1;

                    let queenSideGain = whiteGain.indexOf("d1") != -1 && whiteGain.indexOf("c1") != -1;
                    let kingSideGain = whiteGain.indexOf("f1") != -1 && whiteGain.indexOf("g1") != -1;

                    let queenSideCastle = kingMoved && aRookMoved && queenSideGain;
                    let kingSideCastle = kingMoved && hRookMoved && kingSideGain;

                    if (queenSideCastle) {
                        move = "e1c1";
                    } else if (kingSideCastle) {
                        move = "e1g1";
                    }
                }

                if (moveHasCapture(move)) {
                    if (blackLost.length == 0) {
                        setStatusText("Invalid move - unknown unexpected black piece detected");
                        speakText("Invalid move");
                        possibleMoveConfidence = 0;
                        possibleUserMove = "";
                        return;
                    }
                } else {
                    if (blackLost.length > 0) {
                        setStatusText("Invalid move - unexpected black piece captured: " + blackLost);
                        speakText("Invalid move");
                        possibleMoveConfidence = 0;
                        possibleUserMove = "";
                        return;
                    }
                }

                if (move == "") {
                    console.log("non-valid white move detected: " + whiteLost + " to " + whiteGain + "; " + blackLost + " to " + blackGain);
                    setStatusText("Invalid move - too many pieces moved at once");
                    speakText("Invalid move");
                    possibleMoveConfidence = 0;
                    possibleUserMove = "";
                    return;
                }

                console.log("move detected", move);

                //Process move
                if (move == possibleUserMove) {
                    if (possibleMoveConfidence >= 0) {
                        possibleMoveConfidence++;
                    }
                } else {
                    possibleMoveConfidence = 0;
                    possibleUserMove = move;
                    setStatusText("Player moving... " + move);
                }

                if (possibleMoveConfidence >= 1 && possibleMoveConfidence < 1000) {
                    setStatusText("Player moved " + move, true);
                    if (playerMove(move)) {
                        awaitingRobotMove = true;
                        possibleMoveConfidence = 0;
                        possibleUserMove = "";
                    } else {
                        setStatusText("Illegal move " + move, true);
                        possibleMoveConfidence = 1000; //Lock at high value to prevent further executions
                    }
                } else {
                    //Do nothing until something changes
                }
            }

            //
            // Movement handlers
            //

            function playerMove(m, ignore) {
                m = splitInstSquares(m);
                let promotion = moveHasPromotion(m);
                if (!chess.move({from: m[0], to: m[1], promotion: promotion})) return false;

                console.log("Player moved " + m);
                moves.push(m.join(""));
                board.position(chess.fen())

                console.log(chess.ascii());

                if (ignore) return true;
                if (chess.game_over()) {
                    handleGameOver();
                    return true;
                }
                sendCmds([
                    "position startpos moves " + moves.join(" "),
                    "eval",
                    "go depth " + depth + "wtime 300000 winc 2000 btime 300000 binc 2000"
                ]);
                return true;
            }
            function robotMove(m) {
                m = splitInstSquares(m);
                let captures = moveHasCapture(m);
                let castles = moveHasCastleMove(m);
                let promotion = moveHasPromotion(m);
                if (chess.move({from: m[0], to: m[1], promotion: promotion})) {

                    console.log(
                        "Robot to move " + m
                        + ", capture=" + captures + ", castle=" + castles
                        + ", promotion=" + promotion
                    );

                    if (captures)
                        sendRobotMoves([captures + m[0][0] + '9', m[0] + m[1]]);
                    else if (castles)
                        sendRobotMoves([m[0] + m[1], castles[0] + castles[1]]);
                    else
                        sendRobotMoves([m[0] + m[1]]);

                    moves.push(m.join(""));
                    board.position(chess.fen())

                    console.log("Robot moved " + m);
                    console.log(chess.ascii());

                    if (chess.game_over()) {
                        handleGameOver();
                        return true;
                    }
                }
            }
            function handleGameOver() {
                console.log("Game Over");
            }
            
        </script>
    </body>
</html>
